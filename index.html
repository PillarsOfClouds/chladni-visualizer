<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chladni - Max Sensitivity</title>
    <style>
        *{margin:0;padding:0}
        body{background:#000;overflow:hidden}
        canvas{display:block}
        #start{position:fixed;top:0;left:0;width:100%;height:100%;background:#000;display:flex;flex-direction:column;justify-content:center;align-items:center;cursor:pointer;z-index:10}
        #start.hide{display:none}
        #start span{color:#4f4;font:1rem monospace;letter-spacing:4px}
        #start small{color:#333;font:0.7rem monospace;margin-top:1rem}
    </style>
</head>
<body>
    <div id="start">
        <span>CLICK TO START</span>
        <small>max sensitivity mode</small>
    </div>
    <canvas id="c"></canvas>
    <script>
        const c = document.getElementById('c');
        const ctx = c.getContext('2d');
        let w, h, p = [], analyser, freqData;
        let smoothM = 1, smoothN = 2, smoothLvl = 0;
        let silenceTimer = 0;
        const SILENCE_THRESHOLD = 30;

        function resize() {
            w = c.width = innerWidth;
            h = c.height = innerHeight;
        }

        function init() {
            p = [];
            const cx = w / 2;
            const cy = h / 2;
            
            for (let i = 0; i < 4000; i++) {
                const angle = Math.random() * Math.PI * 2;
                const radius = 50 + Math.random() * Math.min(w, h) * 0.4;
                
                p.push({
                    x: cx + Math.cos(angle) * radius,
                    y: cy + Math.sin(angle) * radius,
                    vx: 0,
                    vy: 0,
                    orbitRadius: radius,
                    orbitAngle: angle,
                    orbitSpeed: (0.2 + Math.random() * 0.8) * (Math.random() > 0.5 ? 1 : -1),
                    orbitDecay: 0.998 + Math.random() * 0.002,
                    orbitCenterX: cx + (Math.random() - 0.5) * 200,
                    orbitCenterY: cy + (Math.random() - 0.5) * 200
                });
            }
        }

        async function startAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({audio: true});
                const actx = new AudioContext();
                analyser = actx.createAnalyser();
                analyser.fftSize = 1024; // Higher resolution FFT
                analyser.smoothingTimeConstant = 0.3; // Less smoothing = faster response
                actx.createMediaStreamSource(stream).connect(analyser);
                freqData = new Uint8Array(analyser.frequencyBinCount);
                return true;
            } catch(e) {
                alert('Mic required');
                return false;
            }
        }

        function getAudio() {
            if (!analyser) return { level: 0, m: 1, n: 2 };
            
            analyser.getByteFrequencyData(freqData);
            
            // 12 frequency bands for fine-grained analysis
            const bandSize = Math.floor(freqData.length / 12);
            const bands = [];
            for (let i = 0; i < 12; i++) {
                let sum = 0;
                for (let j = 0; j < bandSize; j++) {
                    sum += freqData[i * bandSize + j];
                }
                bands.push(sum / bandSize / 255);
            }
            
            // Overall level (very sensitive - use RMS)
            let rmsSum = 0;
            for (let i = 0; i < freqData.length; i++) {
                const normalized = freqData[i] / 255;
                rmsSum += normalized * normalized;
            }
            const level = Math.sqrt(rmsSum / freqData.length);
            
            // Find spectral centroid (center of mass of frequency)
            let weightedSum = 0;
            let totalWeight = 0;
            for (let i = 0; i < freqData.length; i++) {
                weightedSum += i * freqData[i];
                totalWeight += freqData[i];
            }
            const centroid = totalWeight > 0 ? weightedSum / totalWeight / freqData.length : 0.5;
            
            // Calculate spectral spread (how wide the frequency content is)
            let spreadSum = 0;
            for (let i = 0; i < freqData.length; i++) {
                const diff = (i / freqData.length) - centroid;
                spreadSum += diff * diff * freqData[i];
            }
            const spread = totalWeight > 0 ? Math.sqrt(spreadSum / totalWeight) : 0.2;
            
            // Low vs high balance
            const lowEnergy = bands.slice(0, 4).reduce((a,b) => a+b, 0) / 4;
            const midEnergy = bands.slice(4, 8).reduce((a,b) => a+b, 0) / 4;
            const highEnergy = bands.slice(8, 12).reduce((a,b) => a+b, 0) / 4;
            
            // CONTINUOUS m and n values (the key to sensitivity)
            // m: driven by spectral centroid (1 to 7)
            // n: driven by spread and high/low ratio (1 to 7)
            const m = 1 + centroid * 6;
            const hiLoRatio = (highEnergy + midEnergy) / (lowEnergy + 0.01);
            const n = 1 + (spread * 3 + Math.min(hiLoRatio, 1) * 3);
            
            return { level, m, n };
        }

        // Chladni with continuous m,n (not just integers)
        function chladni(x, y, m, n) {
            const nx = (x / w) * 2 - 1;
            const ny = (y / h) * 2 - 1;
            return Math.cos(m * Math.PI * nx) * Math.cos(n * Math.PI * ny) 
                 - Math.cos(n * Math.PI * nx) * Math.cos(m * Math.PI * ny);
        }

        function chladniForce(x, y, m, n) {
            const eps = 2;
            const val = chladni(x, y, m, n);
            const dx = chladni(x + eps, y, m, n) - val;
            const dy = chladni(x, y + eps, m, n) - val;
            const sign = val > 0 ? 1 : -1;
            return { fx: -dx * sign, fy: -dy * sign };
        }

        function loop() {
            const audio = getAudio();
            
            // FAST response - less smoothing
            smoothLvl += (audio.level - smoothLvl) * 0.4;
            smoothM += (audio.m - smoothM) * 0.15;
            smoothN += (audio.n - smoothN) * 0.15;

            // Clear
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            // Very low threshold for sensitivity
            const voiceThreshold = 0.02;
            
            if (smoothLvl > voiceThreshold) {
                silenceTimer = 0;
            } else {
                silenceTimer += 0.016;
            }

            // Mode
            let mode = 0;
            let orbitMode = 0;
            
            if (smoothLvl > voiceThreshold) {
                mode = Math.min(1, (smoothLvl - voiceThreshold) * 15);
                orbitMode = 0;
            } else if (silenceTimer > SILENCE_THRESHOLD) {
                orbitMode = Math.min(1, (silenceTimer - SILENCE_THRESHOLD) * 0.5);
                mode = 0;
            }

            // Use continuous m,n values directly
            const m = smoothM;
            const n = smoothN;

            // Bright green
            ctx.fillStyle = '#0f0';

            const cx = w / 2;
            const cy = h / 2;

            for (let i = 0; i < p.length; i++) {
                const pt = p[i];

                // Orbital mode (30s silence)
                if (orbitMode > 0) {
                    pt.orbitAngle += pt.orbitSpeed * 0.02;
                    pt.orbitRadius *= pt.orbitDecay;
                    
                    if (pt.orbitRadius < 20) {
                        pt.orbitRadius = 50 + Math.random() * Math.min(w, h) * 0.4;
                        pt.orbitCenterX = cx + (Math.random() - 0.5) * 200;
                        pt.orbitCenterY = cy + (Math.random() - 0.5) * 200;
                    }
                    
                    const orbX = pt.orbitCenterX + Math.cos(pt.orbitAngle) * pt.orbitRadius;
                    const orbY = pt.orbitCenterY + Math.sin(pt.orbitAngle) * pt.orbitRadius;
                    
                    const orbStrength = orbitMode * 0.1;
                    pt.vx += (orbX - pt.x) * orbStrength;
                    pt.vy += (orbY - pt.y) * orbStrength;
                }

                // Chladni mode (speaking)
                if (mode > 0) {
                    const force = chladniForce(pt.x, pt.y, m, n);
                    const chladniStrength = mode * smoothLvl * 4;
                    
                    pt.vx += force.fx * chladniStrength;
                    pt.vy += force.fy * chladniStrength;
                    
                    pt.vx += (Math.random() - 0.5) * smoothLvl * 0.2;
                    pt.vy += (Math.random() - 0.5) * smoothLvl * 0.2;
                }

                // Gentle idle drift
                if (mode === 0 && orbitMode === 0) {
                    pt.vx += (Math.random() - 0.5) * 0.1;
                    pt.vy += (Math.random() - 0.5) * 0.1;
                }

                // Apply velocity
                pt.x += pt.vx;
                pt.y += pt.vy;

                // Damping
                const damp = 0.9 - mode * 0.03;
                pt.vx *= damp;
                pt.vy *= damp;

                // Soft bounds
                const margin = 30;
                if (pt.x < margin) pt.vx += 1;
                if (pt.x > w - margin) pt.vx -= 1;
                if (pt.y < margin) pt.vy += 1;
                if (pt.y > h - margin) pt.vy -= 1;

                // Draw
                ctx.fillRect(pt.x, pt.y, 2.5, 2.5);
            }

            requestAnimationFrame(loop);
        }

        // Setup
        resize();
        init();
        onresize = () => { resize(); init(); };

        document.getElementById('start').onclick = async () => {
            if (await startAudio()) {
                document.getElementById('start').className = 'hide';
                loop();
            }
        };
    </script>
</body>
</html>
